for (feature in str_extract_all(rpart.rules, "[a-zA-Z0-9]*")) {
imp.features <- rbind(imp.features, feature[1])
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
var_imp_dt
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
#   for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "[a-zA-Z0-9]*")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
var_imp_dt
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
#   for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "[a-zA-Z]*")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
#   for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "[a-zA-Z.]*")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
var_imp_dt
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
#   for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "[a-zA-Z]*.")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
var_imp_dt
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
#   for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "[a-zA-Z^.]*")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
var_imp_dt
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
#   for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "[a-zA-Z]*")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
var_imp_dt
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
#   for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "[<>]*")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
var_imp_dt
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
#   for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "[^<>]*")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
var_imp_dt
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
#   for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "[^<>0-9]*")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
var_imp_dt
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
#   for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "[^<>0-9]+")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
var_imp_dt
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
#   for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "[\<\>].*$")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
#   for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "\>\<.*$")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
#   for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "><.*$")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
var_imp_dt
# look at the details of this tree
print(dt$finalModel)
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
for (feature in str_extract_all(rpart.rules, "\\w*")) {
# for (feature in str_extract_all(rpart.rules, "><.*$")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
var_imp_dt
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
# for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, ">*")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
var_imp_dt
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
# for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "^>*")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
var_imp_dt
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
# for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "[^>]*")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
var_imp_dt
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
# for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "[^><]*")) {
imp.features <- rbind(imp.features, feature[1])
print(feature)
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
var_imp_dt
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
# for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "[^><]*")) {
imp.features <- rbind(imp.features, feature[1])
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt$finalModel)
var_imp_dt
# plot pruned decision tree
rpart.plot(dt$finalModel, box.palette = "RdGn", roundint = FALSE, main="Pruned Decision Tree")
# look at the details of this tree
print(dt$finalModel)
# summary from training and pruning
dt
dt.pred = predict(dt.model, test.feature ,type="class")
# train decision tree model and prune it
fitcontrol = trainControl(method = "repeatedcv", number = 5, repeats = 1)
set.seed(100)
dt.model = train(train.feature, train.label, method = "rpart",
tuneLength=5, trControl = fitcontrol) # >>> rpart = alpha
# summary from training and pruning
dt.model
# look at the details of this tree
print(dt.model$finalModel)
# plot pruned decision tree
rpart.plot(dt.model$finalModel, box.palette = "RdGn", roundint = FALSE, main="Pruned Decision Tree")
# library(rattle)
# fancyRpartPlot(dt.model$finalModel, palettes=c("Reds", "Greens"), main="Pruned Decision Tree")
# detach(package:rattle)
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
# TODO: fix regex in str_extract_all()
# for (feature in str_extract_all(rpart.rules, "\\w*")) {
for (feature in str_extract_all(rpart.rules, "[^><]*")) {
imp.features <- rbind(imp.features, feature[1])
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt.model$finalModel)
var_imp_dt
dt.pred = predict(dt.model, test.feature ,type="class")
dt.pred = predict(dt.model, test.feature)
mean(dt.pred == test.label)
dt.pred
dt.pred == test.label
str(GermanCredit)
# load German Credit data from caret package
data(GermanCredit)
# delete two variables where all values are the same for both classes
GermanCredit[,c("Purpose.Vacation","Personal.Female.Single")] = list(NULL)
# create training and test sets
set.seed(100)
trainIndex = createDataPartition(GermanCredit$Class, p = 0.7, list = FALSE, times = 1)
train.feature = GermanCredit[trainIndex, -10] # training features
train.label = GermanCredit$Class[trainIndex] # training labels
test.feature = GermanCredit[-trainIndex, -10] # test features
test.label = GermanCredit$Class[-trainIndex] # test labels
# train decision tree model and prune it
fitcontrol = trainControl(method = "repeatedcv", number = 5, repeats = 1)
set.seed(100)
dt.model = train(train.feature, train.label, method = "rpart",
tuneLength=5, trControl = fitcontrol)
# summary from training and pruning
dt.model
# look at the details of this tree
print(dt.model$finalModel)
# plot pruned decision tree
rpart.plot(dt.model$finalModel, box.palette = "RdGn", roundint = FALSE, main="Pruned Decision Tree")
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
for (feature in str_extract_all(rpart.rules, "[^><]*")) {
imp.features <- rbind(imp.features, feature[1])
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt.model$finalModel)
var_imp_dt
dt.pred = predict(dt.model, test.feature, type = "class")
mean(dt.pred == test.label)
dt.pred
dt.pred = predict(dt.model, test.feature)
mean(dt.pred == test.label)
dt.pred
# train decision tree model and prune it
fitcontrol = trainControl(method = "repeatedcv", number = 5, repeats = 1)
set.seed(100)
dt.model = train(train.feature, train.label, method = "rpart",
tuneLength=5, trControl = fitcontrol, parms=list(split='Gini'))
# summary from training and pruning
dt.model
# look at the details of this tree
print(dt.model$finalModel)
# plot pruned decision tree
rpart.plot(dt.model$finalModel, box.palette = "RdGn", roundint = FALSE, main="Pruned Decision Tree")
# extract important features from decision tree
get.dt.features <- function(tree) {
# We will give our users the option to modify the features
# The features we give them depends on the tree model they have generated
# This function will return a list of features that the user can modify
rpart.rules <- data.frame(labels(tree))[1][-1, ]
imp.features <- c()
for (feature in str_extract_all(rpart.rules, "[^><]*")) {
imp.features <- rbind(imp.features, feature[1])
}
output <- unique(imp.features)
return(paste(output))
}
var_imp_dt = get.dt.features(dt.model$finalModel)
var_imp_dt
dt.pred = predict(dt.model, test.feature)
predict.rpart?
dt.pred = predict(dt.model, test.feature, type = "prob")
mean(dt.pred == test.label)
dt.pred
dt.pred = predict(dt.model, test.feature, type = "raw")
dt.pred
dt.pred = predict(dt.model, test.feature)
mean(dt.pred == test.label)
# ROC
confusionMatrix(dt.pred, test.label)
dt.model
dt.model$finalModel
# predict classes
dt.pred = predict(dt.model$finalModel, test.feature)
# test error
mean(dt.pred == test.label)
# predict classes
dt.pred = predict(dt.model, test.feature)
# test error
mean(dt.pred == test.label)
# ROC
confusionMatrix(dt.pred, test.label)
dt.prob = predict(dt.pred, test.feature, type="prob")
dt.pred
dt.prob = predict(dt.model, test.feature, type="prob")
dt.ROC = roc(predictor= dt.prob$Bad,
response = test.label)
library(pROC)
dt.ROC = roc(predictor= dt.prob$Bad,
response = test.label)
dt.ROC$auc
plot(dt.ROC, main="ROC Curve - Decision Tree")
# predict classes
dt.pred = predict(dt.model, test.feature)
# test error
mean(dt.pred == test.label)
# ROC
confusionMatrix(dt.pred, test.label)
dt.prob = predict(dt.model, test.feature, type="prob")
dt.ROC = roc(predictor= dt.prob$Bad,
response = test.label)
dt.ROC$auc
plot(dt.ROC, main="ROC Curve - Decision Tree")
dt.ROC = roc(predictor = dt.prob$Good, response = test.label)
dt.ROC$auc
plot(dt.ROC, main="ROC Curve - Decision Tree")
par(mfrow=c(1,2))
plot(dt.ROC, main="ROC Curve - Decision Tree")
plot(dt.ROC, main="ROC Curve - Random Forest")
par(mfrow=c(1,1))
plot(dt.ROC, main="ROC Curve - Decision Tree")
plot(dt.ROC, main="ROC Curve - Random Forest", add = TRUE)
